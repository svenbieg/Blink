//========
// Pcie.h
//========

#pragma once


//=======
// Using
//=======

#include "Devices/IoHelper.h"
#include <base.h>


//===========
// Namespace
//===========

namespace Devices {
	namespace Pcie {


//==========
// Settings
//==========

constexpr SIZE_T PCIE_OFFSET	=0x0000000000;

constexpr SIZE_T RBAR1_OFFSET	=0xFFFFFFF000; // MSI - 0xFFFFFFF000
constexpr SIZE_T RBAR1_SIZE		=0x1000;

constexpr SIZE_T RBAR2_OFFSET	=AXI_IO_BASE; // AXI - 0x1000000000
constexpr SIZE_T RBAR2_SIZE		=0x100000000;

constexpr SIZE_T OUTWND_OFFSET	=RP1_IO_BASE; // RP1 - 0x1F00000000
constexpr SIZE_T OUTWND_SIZE	=0xFFFFFFFC;

constexpr SIZE_T DMA_OFFSET		=0x1000000000; // 0x1000000000 (64GB)
constexpr SIZE_T DMA_SIZE		=0x1000000000; // 0x1000000000 (64GB)


//=====
// Bus
//=====

enum
{
PCIE_BUS_ONBOARD=0,
PCIE_BUS_EXTERNAL=1
};


//========
// Device
//========

typedef struct
{
UINT RES0;
RW16 CMD;
WORD RES1;
RW32 CLASSREV;
RW08 CACHE_LINE_SIZE;
RW08 LATENCY_TIMER;
RW08 HEADER_TYPE;
BYTE RES2;
RW32 BASE_LO;
RW32 BASE_HI;
RW08 PRIMARY_BUS;
RW08 SECONDARY_BUS;
RW08 SUBORDINATE_BUS;
RW08 SEC_LATENCY_TIMER;
RW32 RES3;
RW16 MEM_BASE;
RW16 MEM_LIMIT;
RW32 RES4[6];
RW08 IRQ_LINE;
RW08 IRQ_PIN;
RW08 BRIDGE_CTRL;
BYTE RES5;
RW32 RES6[27];
RW32 CAPS;
RW32 DEVCAP;
RW32 DEVCTRL;
RW32 LNKCAP;
RW32 LNKCTRL;
RW32 SLOT_CAP;
RW32 SLOT_CTRL;
RW08 ROOT_CTRL;
BYTE RES7[3];
RW32 ROOT_STATUS;
RW32 DEVCAP2;
RW32 DEVCTRL2;
RW32 LNKCAP2;
RW16 LNKCTL2;
WORD RES8;
RW32 SLOT_CAP2;
RW32 SLOT_CTRL2;
RW32 RES9[40];
RW32 VENDOR_SPECIFIC_REG1;
RW32 RES10[172];
RW32 PRIV1_ID_VAL3;
RW32 RES11[39];
RW32 PRIV1_LINK_CAPABILITY;
RW32 RES12[331];
RW32 TL_VDM_CTL1;
RW32 RES13[4];
RW32 TL_VDM_CTL0;
RW32 RES14[375];
}PCIE_REGS;

constexpr UINT BASE_MEM_TYPE_64			=4;

constexpr UINT BRIDGE_CTRL_PARITY		=1;

constexpr BITS CLASSREV_CLASS			={ 0xFFFFFF, 8 };
constexpr UINT CLASSREV_CLASS_HOST		=0x060400;

constexpr WORD CMD_SERR					=(1<<8);
constexpr WORD CMD_PARITY				=(1<<6);
constexpr WORD CMD_MASTER				=(1<<2);
constexpr WORD CMD_MEMORY				=(1<<1);

enum
{
HEADER_TYPE_NORMAL=0,
HEADER_TYPE_BRIDGE=1
};

constexpr UINT LINK_STATE_L0S					=(1<<0);
constexpr UINT LINK_STATE_L1					=(1<<1);

constexpr BITS PRIV1_LINKCAP_ASPM_SUPPORT		={ 0x3, 10 };

constexpr BYTE ROOT_CTRL_CRSSVE					=(1<<4);

constexpr UINT TL_VDM_CTL0_VDM_IGNOREVNDRID		=(1<<18);
constexpr UINT TL_VDM_CTL0_VDM_IGNORETAG		=(1<<17);
constexpr UINT TL_VDM_CTL0_VDM_ENABLED			=(1<<16);


//======
// Host
//======

typedef struct
{
RW32 LOW;
RW32 HIGH;
}MEM_WIN;

typedef struct
{
RW32 BASE;
RW32 LIMIT;
}BASE_LIMIT;

typedef struct
{
PCIE_REGS CFG;
UINT RES9[64];
RW32 DL_MDIO_ADDR;
RW32 DL_MDIO_WR_DATA;
RW32 DL_MDIO_RD_DATA;
UINT RES10[464];
RW32 PL_PHY_CTL_15;
UINT RES11[2542];
RW32 MISC_CTRL;
MEM_WIN CPU2_MEM_WIN[4];
RW32 RC_BAR1_CONFIG_LO;
RW32 RC_BAR1_CONFIG_HI;
RW32 RC_BAR2_CONFIG_LO;
RW32 RC_BAR2_CONFIG_HI;
RW32 RC_BAR3_CONFIG_LO;
RW32 RC_BAR3_CONFIG_HI;
RW32 MSI_BAR_CONFIG_LO;
RW32 MSI_BAR_CONFIG_HI;
RW32 MSI_DATA_CONFIG;
UINT RES12[3];
RW32 RC_CONFIG_RETRY_TIMEOUT;
RW32 EOI_CTRL;
RW32 PCIE_CTRL;
RW32 PCIE_STATUS;
RW32 REVISION;
RW32 CPU2_MEM_WIN_BASE_LIMIT[4];
BASE_LIMIT CPU2_MEM_WIN_BASE_LIMIT_HI[4];
RW32 MISC_CTRL1;
RW32 UBUS_CTRL;
RW32 UBUS_TIMEOUT;
RW32 UBUS_BAR1_CONFIG_REMAP;
RW32 UBUS_BAR1_CONFIG_REMAP_HI;
RW32 UBUS_BAR2_CONFIG_REMAP;
UINT RES13[43];
RW32 VDM_PRIORITY_TO_QOS_MAP_HI;
RW32 VDM_PRIORITY_TO_QOS_MAP_LO;
RW32 AXI_INTF_CTRL;
RW32 AXI_READ_ERROR_DATA;
UINT RES14[100];
RW32 HARD_DEBUG;
UINT RES15[62];
RW32 INTR2_CPU_BASE[64];
RW32 INTR2_MSI_BASE[64];
UINT RES16[3712];
PCIE_REGS CFG_DATA;
RW32 CFG_INDEX;
}PCIE_HOST_REGS;

constexpr UINT AXI_INTF_CTRL_REQFIFO_EN_QOS_PROP	=(1<<7);

constexpr BITS CFG_INDEX_BUS						={ 0xFFF, 20 };
constexpr BITS CFG_INDEX_FUNC						={ 0x7, 12 };
constexpr BITS CFG_INDEX_SLOT						={ 0x1F, 15 };

constexpr BITS CPU2_MEM_WIN_BASE_LIMIT_LIMIT		={ 0xFFF, 20 };
constexpr BITS CPU2_MEM_WIN_BASE_LIMIT_BASE			={ 0xFFF, 4 };
constexpr UINT CPU2_MEM_WIN_BASE_LIMIT_NUM_BITS		=12;
constexpr UINT CPU2_MEM_WIN_BASE_LIMIT_HI_MASK		=0xFF;

constexpr UINT HARD_DEBUG_CLKREQ_L1SS_EN			=(1<<21);

constexpr BITS MISC_CTRL_SCB0_SIZE					={ 0x1F, 27 };
constexpr BITS MISC_CTRL_MAX_BURST_SIZE				={ 0x3, 20 };
constexpr UINT MISC_CTRL_MAX_BURST_SIZE_256			=1;
constexpr UINT MISC_CTRL_CFG_READ_UR_MODE			=(1<<13);
constexpr UINT MISC_CTRL_SCB_ACCESS_EN				=(1<<12);
constexpr UINT MISC_CTRL_RCB_MPS_MODE				=(1<<10);

constexpr UINT MISC_CTRL1_EN_VDM_QOS_CONTROL		=(1<<5);
constexpr UINT MISC_CTRL1_OUTBOUND_RO				=(1<<4);
constexpr UINT MISC_CTRL1_OUTBOUND_NO_SNOOP			=(1<<3);
constexpr UINT MISC_CTRL1_OUTBOUND_TC_MASK			=0xF;

constexpr UINT PCIE_CTRL_PERST						=(1<<2);

constexpr UINT PCIE_STATUS_DL_ACTIVE				=(1<<5);
constexpr UINT PCIE_STATUS_PHYLINKUP				=(1<<4);

constexpr BITS PL_PHY_CTL_15_CLOCK_PERIOD			={ 0xFF, 0 };
constexpr UINT PL_PHY_CTL_15_CLOCK_PERIOD_DEFAULT	=0x12;

constexpr UINT RC_BAR_CONFIG_LO_SIZE				=0x1F;

constexpr UINT UBUS_BAR_CONFIG_REMAP_ACCESS_EN		=(1<<0);

constexpr UINT UBUS_CTRL_REPLY_DECERR_DIS			=(1<<19);
constexpr UINT UBUS_CTRL_REPLY_ERR_DIS				=(1<<13);


//======
// Mdio
//======

constexpr BYTE MDIO_REG_SET_ADDR_OFFSET		=0x1F;

constexpr BITS MDIO_PORT					={ 0xF, 22 };
constexpr BITS MDIO_CMD						={ 0x3, 20 };
constexpr BITS MDIO_REG						={ 0xFFFF, 0 };
constexpr UINT MDIO_DATA_DONE				=(1<<31);
constexpr UINT MDIO_DATA_MASK				=0x7FFFFFFF;

enum
{
MDIO_CMD_WRITE=0,
MDIO_CMD_READ=1
};


//============
// Interrupts
//============

constexpr UINT32 RP1_IRQ_COUNT			=48;
constexpr UINT64 RP1_IRQ_EDGE_MASK		=0x18C0000000ULL;

typedef VOID (*IRQ_HANDLER)(VOID* Parameter);

enum class Rp1Irq
{
IoBank0=0,
IoBank1=1,
IoBank2=2,
Ethernet=6,
I2s0=14,
I2s1=15,
UArt0=25,
Xhci0=30,
Xhci0_0=31,
Xhci1=35,
Xhci1_0=36,
Dma=40,
UArt1=42,
UArt2=43,
UArt3=44,
UArt4=45,
UArt5=46
};

typedef struct
{
RW32 REG_RW;
UINT RES0[65];
RO64 INT_STAT;
UINT RES1[446];
RW32 MSIX_CFG_SET[64];
UINT RES2[192];
RW32 MSIX_CFG_CLEAR[64];
}rp1_intc_regs_t;

constexpr UINT MSIX_CFG_IACK_EN		=(1<<3);
constexpr UINT MSIX_CFG_IACK		=(1<<2);
constexpr UINT MSIX_CFG_EN			=(1<<0);

}}